\timing on
\x auto
\set HISTCONTROL ignoredups

-- aliases can be executed via a leading colon (eg. :databases)
-- some aliases may accept additional args (eg. :type my_type)
\set databases '\\l'
\set tables '\\dt'
\set type '\\dT+'

-- incomplete sql statements can be specified, and completed when typing the alias
-- (eg. :size limit 5;)
-- they also should support filtering/ordering by any column via appending an
-- underscore to target the unformatted value
-- (eg. :size order by table_size_ desc limit 5;)

\set size 'select tbl, to_char(tablerows_, ''999,999,999,999'') tablerows, to_char(deadrows_, ''999,999,999'') deadrows, pg_size_pretty(table_size_) table_size, pg_size_pretty(indexes_size_) indexes_size, to_char(seq_scans_, ''999,999,999,999'') seq_scans, to_char(index_scans_, ''999,999,999,999'') index_scans from (select tbl, n_live_tup tablerows_, n_dead_tup deadrows_, pg_relation_size(tbl) table_size_, pg_indexes_size(tbl) indexes_size_, seq_scan seq_scans_, idx_scan index_scans_ from (select (schemaname || ''.'' || ''"'' || relname || ''"'')::regclass::varchar tbl, n_live_tup, n_dead_tup, seq_scan, idx_scan from pg_stat_user_tables where schemaname not in (''pglogical'')) t) s'

\set idx 'select tbl, idx, pg_size_pretty(idx_size_) idx_size, to_char(idx_scans_, ''999,999,999,999'') idx_scans, idx_def from (select (ia.schemaname || ''.'' || ''"'' || ia.relname || ''"'')::regclass::varchar tbl, indexrelname idx, pg_relation_size(indexrelid) idx_size_, idx_scan idx_scans_, regexp_replace(indexdef, ''CREATE (UNIQUE )?INDEX .* USING (btree )?'', ''\\1'') idx_def from pg_stat_all_indexes ia join pg_indexes i on i.indexname = ia.indexrelname join pg_class c on ia.relid = c.oid where ia.schemaname not in (''pg_catalog'', ''pg_toast'', ''pglogical'')) i'

\set hot 'select tbl, to_char(updates_, ''999,999,999,999'') updates, to_char(hot_, ''999,999,999,999'') hot, (percent_::varchar || ''%'') percent from (select (schemaname || ''.'' || ''"'' || relname || ''"'')::regclass::varchar tbl, n_tup_upd updates_, n_tup_hot_upd hot_, case when n_tup_upd > 0 then (n_tup_hot_upd * 100 / n_tup_upd) else 0 end percent_ from pg_stat_all_tables where schemaname not in (''pg_catalog'', ''pg_toast'', ''information_schema'', ''pglogical'') and n_tup_upd > 0) h'
